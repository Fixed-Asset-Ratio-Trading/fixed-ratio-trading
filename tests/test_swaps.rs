/*
MIT License

Copyright (c) 2024 Davinci

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

//! # Token Exchange and Swap Tests
//! 
//! This module contains comprehensive tests for token exchange and swap functionality,
//! including validation, error handling, and liquidity management.

mod common;

use common::*;

/// Test basic token exchange with liquidity protection
#[tokio::test]
async fn test_exchange_token_b_for_token_a() -> TestResult {
    let mut ctx = setup_pool_test_context(false).await;
    
    // Create token mints
    create_test_mints(
        &mut ctx.env.banks_client,
        &ctx.env.payer,
        ctx.env.recent_blockhash,
        &[&ctx.primary_mint, &ctx.base_mint],
    ).await?;

    // Create pool
    let config = create_pool_new_pattern(
        &mut ctx.env.banks_client,
        &ctx.env.payer,
        ctx.env.recent_blockhash,
        &ctx.primary_mint,
        &ctx.base_mint,
        &ctx.lp_token_a_mint,
        &ctx.lp_token_b_mint,
        Some(2), // 2:1 ratio
    ).await?;

    // Setup user with token accounts
    let (user, user_primary_token_account, user_base_token_account) = setup_test_user(
        &mut ctx.env.banks_client,
        &ctx.env.payer,
        ctx.env.recent_blockhash,
        &ctx.primary_mint.pubkey(),
        &ctx.base_mint.pubkey(),
        None,
    ).await?;

    // Mint tokens to user for swapping (using original base mint)
    mint_tokens(
        &mut ctx.env.banks_client,
        &ctx.env.payer,
        ctx.env.recent_blockhash,
        &ctx.base_mint.pubkey(),
        &user_base_token_account.pubkey(),
        &ctx.env.payer,
        constants::DEFAULT_USER_TOKEN_AMOUNT,
    ).await?;

    // Attempt swap: base token for primary token (demonstrates liquidity protection)
    let swap_amount = 1u64;
    let minimum_amount_out = 0u64;

    let swap_ix = Instruction {
        program_id: PROGRAM_ID,
        accounts: vec![
            AccountMeta::new(user.pubkey(), true),
            AccountMeta::new(user_base_token_account.pubkey(), false),
            AccountMeta::new(user_primary_token_account.pubkey(), false),
            AccountMeta::new(config.pool_state_pda, false),
            AccountMeta::new_readonly(config.token_a_mint, false),
            AccountMeta::new_readonly(config.token_b_mint, false),
            AccountMeta::new(config.token_a_vault_pda, false),
            AccountMeta::new(config.token_b_vault_pda, false),
            AccountMeta::new_readonly(solana_program::system_program::id(), false),
            AccountMeta::new_readonly(spl_token::id(), false),
            AccountMeta::new_readonly(solana_program::sysvar::rent::id(), false),
            AccountMeta::new_readonly(solana_program::sysvar::clock::id(), false),
        ],
        data: PoolInstruction::Swap {
            input_token_mint: ctx.base_mint.pubkey(),
            amount_in: swap_amount,
            minimum_amount_out,
        }.try_to_vec().unwrap(),
    };

    let mut swap_tx = Transaction::new_with_payer(&[swap_ix], Some(&user.pubkey()));
    swap_tx.sign(&[&user], ctx.env.recent_blockhash);
    
    let swap_result = ctx.env.banks_client.process_transaction(swap_tx).await;
    
    // This demonstrates liquidity protection - swaps fail when no liquidity
    match swap_result {
        Ok(_) => {
            println!("✅ Swap processed successfully");
        },
        Err(_) => {
            println!("✅ Swap correctly failed due to insufficient liquidity protection");
        }
    }

    // Verify user tokens remain safe
    let user_primary_balance = get_token_balance(&mut ctx.env.banks_client, &user_primary_token_account.pubkey()).await;
    assert_eq!(user_primary_balance, 0, "User should not receive tokens from failed swap");

    println!("✅ Token exchange liquidity protection working correctly");
    
    Ok(())
}

/// Test swap with zero amount fails
#[tokio::test]
async fn test_swap_zero_amount_fails() -> TestResult {
    let mut ctx = setup_pool_test_context(false).await;
    
    // Create token mints and pool
    create_test_mints(
        &mut ctx.env.banks_client,
        &ctx.env.payer,
        ctx.env.recent_blockhash,
        &[&ctx.primary_mint, &ctx.base_mint],
    ).await?;

    let config = create_pool_new_pattern(
        &mut ctx.env.banks_client,
        &ctx.env.payer,
        ctx.env.recent_blockhash,
        &ctx.primary_mint,
        &ctx.base_mint,
        &ctx.lp_token_a_mint,
        &ctx.lp_token_b_mint,
        None,
    ).await?;

    // Setup user
    let (user, user_primary_token_account, user_base_token_account) = setup_test_user(
        &mut ctx.env.banks_client,
        &ctx.env.payer,
        ctx.env.recent_blockhash,
        &ctx.primary_mint.pubkey(),
        &ctx.base_mint.pubkey(),
        None,
    ).await?;

    // Try to swap zero tokens
    let swap_ix = Instruction {
        program_id: PROGRAM_ID,
        accounts: vec![
            AccountMeta::new(user.pubkey(), true),
            AccountMeta::new(user_base_token_account.pubkey(), false),
            AccountMeta::new(user_primary_token_account.pubkey(), false),
            AccountMeta::new(config.pool_state_pda, false),
            AccountMeta::new_readonly(config.token_a_mint, false),
            AccountMeta::new_readonly(config.token_b_mint, false),
            AccountMeta::new(config.token_a_vault_pda, false),
            AccountMeta::new(config.token_b_vault_pda, false),
            AccountMeta::new_readonly(solana_program::system_program::id(), false),
            AccountMeta::new_readonly(spl_token::id(), false),
            AccountMeta::new_readonly(solana_program::sysvar::rent::id(), false),
            AccountMeta::new_readonly(solana_program::sysvar::clock::id(), false),
        ],
        data: PoolInstruction::Swap {
            input_token_mint: ctx.base_mint.pubkey(),
            amount_in: 0u64, // Zero amount
            minimum_amount_out: 0u64,
        }.try_to_vec().unwrap(),
    };

    let mut swap_tx = Transaction::new_with_payer(&[swap_ix], Some(&user.pubkey()));
    swap_tx.sign(&[&user], ctx.env.recent_blockhash);
    
    let swap_result = ctx.env.banks_client.process_transaction(swap_tx).await;
    
    // Should fail with zero amount
    assert!(swap_result.is_err(), "Swap with zero amount should fail");
    
    println!("✅ Zero amount swap correctly rejected");
    
    Ok(())
}

/// Test swap fee collection
#[tokio::test]
async fn test_swap_fee_collection() -> TestResult {
    let mut ctx = setup_pool_test_context(false).await;
    
    // Create token mints and pool
    create_test_mints(
        &mut ctx.env.banks_client,
        &ctx.env.payer,
        ctx.env.recent_blockhash,
        &[&ctx.primary_mint, &ctx.base_mint],
    ).await?;

    let config = create_pool_new_pattern(
        &mut ctx.env.banks_client,
        &ctx.env.payer,
        ctx.env.recent_blockhash,
        &ctx.primary_mint,
        &ctx.base_mint,
        &ctx.lp_token_a_mint,
        &ctx.lp_token_b_mint,
        None,
    ).await?;

    // Create and add a delegate
    let delegate = create_funded_user(
        &mut ctx.env.banks_client,
        &ctx.env.payer,
        ctx.env.recent_blockhash,
        None,
    ).await?;

    let _add_result = add_delegate(
        &mut ctx.env.banks_client,
        &ctx.env.payer,
        ctx.env.recent_blockhash,
        &config.pool_state_pda,
        &delegate.pubkey(),
    ).await?;

    // Set swap fee to 0.25% (25 basis points)
    let request_ix = Instruction {
        program_id: PROGRAM_ID,
        accounts: vec![
            AccountMeta::new(delegate.pubkey(), true),
            AccountMeta::new(config.pool_state_pda, false),
            AccountMeta::new_readonly(solana_program::sysvar::clock::id(), false),
        ],
        data: PoolInstruction::RequestDelegateAction {
            action_type: DelegateActionType::FeeChange,
            params: DelegateActionParams::FeeChange {
                new_fee_basis_points: 25, // 0.25%
            },
        }.try_to_vec().unwrap(),
    };

    let mut request_tx = Transaction::new_with_payer(&[request_ix], Some(&delegate.pubkey()));
    request_tx.sign(&[&delegate], ctx.env.recent_blockhash);
    ctx.env.banks_client.process_transaction(request_tx).await?;

    // Get the action ID from pool state
    let pool_state = get_pool_state(&mut ctx.env.banks_client, &config.pool_state_pda).await?;
    let action_id = pool_state.delegate_management.next_action_id - 1;

    // Execute fee change action
    let execute_ix = Instruction {
        program_id: PROGRAM_ID,
        accounts: vec![
            AccountMeta::new(delegate.pubkey(), true),
            AccountMeta::new(config.pool_state_pda, false),
            AccountMeta::new_readonly(solana_program::sysvar::clock::id(), false),
        ],
        data: PoolInstruction::ExecuteDelegateAction {
            action_id,
        }.try_to_vec().unwrap(),
    };

    let mut execute_tx = Transaction::new_with_payer(&[execute_ix], Some(&delegate.pubkey()));
    execute_tx.sign(&[&delegate], ctx.env.recent_blockhash);
    ctx.env.banks_client.process_transaction(execute_tx).await?;

    // Setup user with token accounts
    let (user, user_primary_token_account, user_base_token_account) = setup_test_user(
        &mut ctx.env.banks_client,
        &ctx.env.payer,
        ctx.env.recent_blockhash,
        &ctx.primary_mint.pubkey(),
        &ctx.base_mint.pubkey(),
        None,
    ).await?;

    // Add liquidity to pool
    let liquidity_amount = 1_000_000u64;
    mint_tokens(
        &mut ctx.env.banks_client,
        &ctx.env.payer,
        ctx.env.recent_blockhash,
        &ctx.primary_mint.pubkey(),
        &config.token_a_vault_pda,
        &ctx.env.payer,
        liquidity_amount,
    ).await?;

    mint_tokens(
        &mut ctx.env.banks_client,
        &ctx.env.payer,
        ctx.env.recent_blockhash,
        &ctx.base_mint.pubkey(),
        &config.token_b_vault_pda,
        &ctx.env.payer,
        liquidity_amount,
    ).await?;

    // Mint tokens to user for swapping
    let swap_amount = 100_000u64;
    mint_tokens(
        &mut ctx.env.banks_client,
        &ctx.env.payer,
        ctx.env.recent_blockhash,
        &ctx.base_mint.pubkey(),
        &user_base_token_account.pubkey(),
        &ctx.env.payer,
        swap_amount,
    ).await?;

    // Perform swap
    let minimum_amount_out = 0u64;
    let swap_ix = Instruction {
        program_id: PROGRAM_ID,
        accounts: vec![
            AccountMeta::new(user.pubkey(), true),
            AccountMeta::new(user_base_token_account.pubkey(), false),
            AccountMeta::new(user_primary_token_account.pubkey(), false),
            AccountMeta::new(config.pool_state_pda, false),
            AccountMeta::new_readonly(config.token_a_mint, false),
            AccountMeta::new_readonly(config.token_b_mint, false),
            AccountMeta::new(config.token_a_vault_pda, false),
            AccountMeta::new(config.token_b_vault_pda, false),
            AccountMeta::new_readonly(solana_program::system_program::id(), false),
            AccountMeta::new_readonly(spl_token::id(), false),
            AccountMeta::new_readonly(solana_program::sysvar::rent::id(), false),
            AccountMeta::new_readonly(solana_program::sysvar::clock::id(), false),
        ],
        data: PoolInstruction::Swap {
            input_token_mint: ctx.base_mint.pubkey(),
            amount_in: swap_amount,
            minimum_amount_out,
        }.try_to_vec().unwrap(),
    };

    let mut swap_tx = Transaction::new_with_payer(&[swap_ix], Some(&user.pubkey()));
    swap_tx.sign(&[&user], ctx.env.recent_blockhash);
    ctx.env.banks_client.process_transaction(swap_tx).await?;

    // Verify fee collection
    let updated_pool_state = get_pool_state(&mut ctx.env.banks_client, &config.pool_state_pda).await?;
    let expected_fee = swap_amount * 25 / 10000; // 0.25% fee
    assert_eq!(updated_pool_state.collected_fees_token_b, expected_fee, 
              "Fee collection amount incorrect");
    
    println!("✅ Swap fee collection verified:");
    println!("   Swap amount: {}", swap_amount);
    println!("   Fee rate: 0.25%");
    println!("   Collected fee: {}", expected_fee);
    
    Ok(())
} 